<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 回调地狱---一层一层的嵌套作用，，，再一层层的回调
        // console.log('发送请求1');
        // setTimeout(() => {
        //     console.log('请求1成功');

        //     console.log('发送请求2');
        //     setTimeout(() => {
        //         console.log('请求2成功');
        //     }, 1000);
        // }, 1000);

        // 用同步的写法，解决异步回调地狱---promise
        // 实例化一个promise的对象p1

        // first  then  catch
        // let p1=new Promise(function(resolve,reject) {
        //     // 形参一：成功的回调函数
        //     // 形参二：失败的回调函数
        //     console.log('发送请求1');
        //     let tag=false;
        //     setTimeout(() => {
        //         if(tag){
        //             // 请求成功
        //             resolve();
        //         }
        //         else{
        //             // 请求失败
        //             reject();
        //         }
        //     }, 1000);
        // }).then(function(){
        //     // p1.then(参数),如果请求成功进入then函数 resovle()
        //     console.log('请求1成功');
        // }).catch(function(){
        //     // p1.then(参数).catch(参数)方法，如果请求失败，进入catch函数  reject()
        //     console.log('请求1失败');
        // })

        // second  then
        let p2=new Promise((resolve,reject) => {
            console.log('发送请求1');
            setTimeout(() => {
                let tag=true;
                if(tag){
                    resolve();
                }else{
                    reject();
                }
            }, 1000);
        }).then(function(){
            // p1.then(参数，参数)函数有两个参数，第一个参数代表成功请求
            // 成功
            console.log('请求1成功');
        },function(){
            // 失败
            console.log('请求1失败');
        })
    </script>
</body>
</html>